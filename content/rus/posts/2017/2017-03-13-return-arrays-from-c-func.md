---
title: Как вернуть массив из C-функции.
date: 2017-03-13
categories:
- develop
---

## Введение в проблему

Про то, как вернуть массив из функции на языке C, написано достаточно много статей.
Все же мне бы хотелось обобщить техники, с помощью, которых это можно сделать.

Давайте для примера разработаем функцию, которая будет конвертировать число в строковое
представление (эта функция будет обратная функции atoi), назовем её itoa. Как она должна
возвращать сгенерированную (строку) последовательность цифр?

В этой заметке рассмотрим три техники.

> Для простоты примера не будем реализовывать цикл do/while, а просто воспользуемся функцией sprintf.
Вызов этой функции настолько прост, что большинство C программ используют его непосредственно,
поэтому, наверное, и нет стандартной функции itoa.

Давайте, посмотрим на вариант, который _не_ будет работать, поэтому не пишите такой код.

```c
char *itoa(int n)
{
    char retbuf[25];
    sprintf(retbuf, "%d", n);
    return retbuf;
}
```

На первый взгляд реализация выглядит вполне разумной (в _некоторых_ случаях, этот код будет работать правильно).
Тем не менее, этот код содержит серьезную ошибку, посмотрите на переменную retbuf – это локальная переменная.
Так как, это обычная локальная переменная функции, она имеет автоматическую длительность хранения.

> Идентификатор с автоматической длительностью хранения ("локальный идентификатор") имеет выделенную память
и определенное значение только внутри блока, в котором он определен или объявлен. Автоматическому идентификатору
выделяется новая память при каждом входе программы в соответствующий блок; при выходе программы из этого
блока память (и значение) идентификатора освобождается.

Таким образом, указатель на массив, который возвращает функция itoa уже не будет существовать, когда вызывающий
код получит значение. (Оператор return retbuf; возвращает указатель на первый элемент массива retbuf.
В следствии эквивалентности массивов и указателей retbuf равносильно &retbuf[0]). Когда вызывающий код попытается
использовать указатель на созданную функцией itoa строку, он может быть все ещё валидный, либо память может уже
использоваться другой функцией. Вот почему первая версия нашей функции itoa не правильная. Функция никогда не должна
возвращать указатель на локальные переменные с автоматическим временем жизни.

## Техника со статически выделенным массивом (static array technique)

Проблема с возвращением указателя на локальный массив заключается в том, что время жизни у данной переменной
автоматическое по умолчанию, самый простой способ исправить ситуацию не изменяя саму функцию itoa - это объявить
массив с модификатором  static.

```c
char *itoa(int n)
{
    static char retbuf[25];
    sprintf(retbuf, "%d", n);
    return retbuf;
}
```

Возвращение указателя на статический выделенный массив является достаточно часто используемым решением, но у него
есть один недостаток. Каждый раз, когда вы вызываете функцию, она использует тот же самый массив и возвращает тот
же самый указатель. Поэтому, когда вы вызываете функцию второй раз, информация на которую указывает указатель будет перезаписана.

Рассмотрим такой пример:

```c
int i = 23;
char *p1, *p2;
p1 = itoa(i);
i = i + 10;
p2 = itoa(i);
printf("old i = %s, new i = %s\n", p1, p2);
```

Этот код будет работать не так как мы можем ожидать. Второй вызов функции itoa перезапишет строку, которая была получена
при первом вызове. Вместо того, чтобы вывести на печать старое и новое значение, будет выведено новое значение дважды.
Обе переменные p1 и p2 будут указывать на одно и тоже место, т.к. каждый вызов itoa всегда будет возвращать один тот же указатель.

Рассмотрим ещё такой пример:

```c
printf("i = %s, j = %s\n", itoa(i), itoa(j));
```

Где i и j две разные int переменные. Что произойдет? Либо компилятор вызовет первой первую функцию itoa либо вторую.
(Разные компиляторы могут вести себя по разному.) В каком бы порядке не происходил вызов функций результат будет один.
Функция printf напечатает два одинаковых значения.

> Вывод: реализация со статической переменной является работоспособной, но результат в вызывающем коде необходимо
использовать с осторожностью, т.к. последующие вызовы функции затрут результаты предыдущего вызова.

Иногда, это ограничение является существенным, в других ситуациях, это вполне приемлемо. (Некоторые функции из стандартной
C библиотеки используют эту технику, например, ctime, которая конвертирует timestamp в строковое представление. Когда
в мане вы видите фразу наподобие: "The returned pointer is to static data which is overwritten with each call'' - это
означает, что функция использует данную технику.

Если, указанное выше, ограничение нам не походит, можно использовать одну из следующих техник.

## Техника с передачей в функцию указателя на выделенный массив (caller-passes-an-array)

Если, использование статически выделенного, массива для хранения, возвращаемого, результата нам не подходит, то следующий
вариант – это выделение массива в вызывающем коде и передача указателя в вызываемую функцию.

В этом случае функция будет принимать, по меньшей мере, один дополнительный параметр (в дополнение к любым другим) - указатель
на место в памяти, куда необходимо записать результат. Подобным образом работает функция getline. Давайте перепишем нашу функцию подобным образом:

```c
char *itoa(int n, char buf[])
{
    sprintf(buf, "%d", n);
    return buf;
}
```

Теперь вызывающий код должен передать в функцию число и указатель на массив, куда необходимо созранить результат:

```c
int i = 23;
char buf[25];
char *str = itoa(i, buf);
```

Конечно, есть пара отличий между нашей функцией и getline, если не считать, что они делают разные вещи.
Во-первых, getline принимает дополнительные параметры, в частности размер массива, для избежание переполнения.
Наша новая версия не принимает такой параметр. Если вызывающий код передаст указатель на слишком маленький массив,
то мы можем выйти за границы массива и затереть "чужую" память. (Естественно, последствия могут быть катастрофическими
для нашего приложения.)

Тем не менее, вторая, рассмотренная, стратегия так же популярна и работоспособна, как и первая со статической
локальной переменной. Вот ещё несколько функций, в которых реализована подобная техника: fgets, fread.

## Техника с выделением памяти в куче в вызываемой функции (function-calls-malloc technique)

В тех случаях, когда две выше перечисленные техники не походят (со статическим выделением памяти и выделением
массива в вызывающем коде с передачей указателя в вызываемую функцию), можно использовать третий подход,
а именно динамическое выделение памяти внутри вызываемой функции. Ниже новая версия itoa, демонстрирующая данную технику:

```c
char *itoa(int n)
{
    char *retbuf = malloc(25);
    if(retbuf == NULL)
        return NULL;
    sprintf(retbuf, "%d", n);
    return retbuf;
}
```

Теперь получить результат в вызывающем коде можно достаточно просто:

```c
char *p = itoa(i);
```

В данной технике мы должны заботиться о следующих вещах:

1. Новая функция itoa возвращает NULL указатель, если функция malloc не смогла выделить память. Поэтому, в вызывающем
   коде, мы должны проверять возвращаемый результат каждый раз при вызове itoa до того, как начать использовать полученный указатель.
2. Если мы вызовем функцию itoa 10000 раз, мы выделим 25 * 10000 = 250000 байт памяти. Для освобождения этой памяти
   необходимо использовать функцию free. Вызывающий код обязан отслеживать каждый указатель и при необходимости освобождать
   занятую память, в противном случае мы можем получить утечку памяти.

Первую, выше указанную, проблему можно решить следующим образом. Предположим, что у нас достаточно памяти и вызов функции
malloc будет редко приводить к ошибке, а в случае ошибки мы просто будет выводить сообщение об ошибке и завершать программу.
Таким образом проверку на нулевой указатель мы можем переместить в функцию itoa.

```c
char *retbuf = malloc(25);
if(retbuf == NULL)
{
    fprintf(stderr, "out of memory\n");
    exit(EXIT_FAILURE);
}
```

Теперь, функция не будет возвращать нулевой указатель, поэтому вызывающему коду не нужно об этом заботиться.
Проблема только в том, что если функция malloc завершилась с ошибкой, наша программа прервет свою работу.

## Итоги

Таким образом мы имеем в арсенале три метода возврата массивов из функции, ни один из которых не является совершенным и лишенным недостатков.

1. Техника со статическим массивом удобна для вызывающего кода, но только не для случаев когда нужно вызвать несколько раз данную функцию
   и получить несколько результатов. (Так же техника со статическим массивом нарушает идею, о том, что вызывающий код ничего не должен знать
   о внутреннем устройстве вызываемой функции, в данном случае нам нужно знать, что массив является статическим).
2. Метод, в котором, вызывающий код передает в функцию указатель на массив может использоваться в тех случаях,
   когда необходимо несколько раз вызвать функцию и получить множество результатов. Этот прием хорош, когда количество
   таких вызовов не велико, и вызывающий код может легко отслеживать передаваемые массивы.
3. И, наконец, последнюю технику, удобно использовать в тех случаях, когда нам необходимо вызвать функцию множество раз,
   либо нужна максимальная гибкость. За данную гибкость и удобство нам придется платить - в вызывающем коде необходимо
   освобождать выделенную память.