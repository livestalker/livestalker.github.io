<!doctype html><html dir=ltr lang=ru data-theme><head>
<title>
Alexey V. Grebenshchikov
|
Как вернуть массив из C-функции.
</title>
<meta charset=utf-8><meta name=generator content="Hugo 0.86.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name=description content="
      My personal blog


    ">
<link rel=stylesheet href=/css/main.min.51423ad97099a08f3a20e16d238c13adae76db7dd5e1913789bdc81143ff4cc6.css integrity="sha256-UUI62XCZoI86IOFtI4wTra52233V4ZE3ib3IEUP/TMY=" crossorigin=anonymous type=text/css>
<link rel=stylesheet href=/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS+yuWSR4=" crossorigin=anonymous type=text/css>
<link rel=stylesheet href=/css/fontawesome.min.490e7206ebbf2628348fee7a4e46903aef25f4a7e993c4f0f30dba677cd3d51b.css integrity="sha256-SQ5yBuu/Jig0j+56TkaQOu8l9Kfpk8Tw8w26Z3zT1Rs=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous>
<link rel="shortcut icon" href=/favicon.ico type=image/x-icon>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=canonical href=/ru/posts/2017/2017-03-13-return-arrays-from-c-func/>
<script type=text/javascript src=/js/anatole-header.min.2a2cd9614b7d007dfbb75e8da19e3a0fa872ceab53c6d000c00b7a0c89b85bfc.js integrity="sha256-KizZYUt9AH37t16NoZ46D6hyzqtTxtAAwAt6DIm4W/w=" crossorigin=anonymous></script>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Как вернуть массив из C-функции.">
<meta name=twitter:description content="Введение в проблему Про то, как вернуть массив из функции на языке C, написано достаточно много статей.">
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Как вернуть массив из C-функции.","headline":"Как вернуть массив из C-функции.","alternativeHeadline":"","description":"
      
        Введение в проблему Про то, как вернуть массив из функции на языке C, написано достаточно много статей.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/sysctl.ru\/ru\/posts\/2017\/2017-03-13-return-arrays-from-c-func\/"},"author":{"@type":"Person","name":"Alexey V. Grebenshchikov"},"creator":{"@type":"Person","name":"Alexey V. Grebenshchikov"},"accountablePerson":{"@type":"Person","name":"Alexey V. Grebenshchikov"},"copyrightHolder":{"@type":"Person","name":"Alexey V. Grebenshchikov"},"copyrightYear":"2017","dateCreated":"2017-03-13T00:00:00.00Z","datePublished":"2017-03-13T00:00:00.00Z","dateModified":"2017-03-13T00:00:00.00Z","publisher":{"@type":"Organization","name":"Alexey V. Grebenshchikov","url":"https://sysctl.ru/","logo":{"@type":"ImageObject","url":"https:\/\/sysctl.ru\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/sysctl.ru\/ru\/posts\/2017\/2017-03-13-return-arrays-from-c-func\/","wordCount":"1273","genre":["develop"],"keywords":[]}</script>
</head>
<body>
<header><div class="page-top
.">
<a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false>
<span aria-hidden=true></span>
<span aria-hidden=true></span>
<span aria-hidden=true></span>
</a>
<nav>
<ul class=nav__list id=navMenu>
<div class=nav__links>
<li>
<a href=/ru/ title>Главная</a>
</li>
<li>
<a href=/ru/posts/ title>Посты</a>
</li>
<li>
<a href=/ru/cv/ title>CV</a>
</li>
<li><a href=/ title=EN>EN</a></li>
<li><a href=/ru/ title=RU>RU</a></li>
</div>
<li>
</li>
</ul>
</nav>
</div>
</header>
<div class=wrapper>
<aside><div class="sidebar
.">
<div class=sidebar__content>
<div class=logo-title>
<div class=title>
<img src=/images/avg.jpeg alt="profile picture">
<h3 title><a href=/>Alexey V. Grebenshchikov</a></h3>
<div class=description>
<p>My personal blog</p>
</div>
</div>
</div>
<ul class=social-links>
<li>
<a href=https://www.linkedin.com/in/aleksiog/ rel=me aria-label=Linkedin>
<i class="fab fa-linkedin fa-2x" aria-hidden=true></i>
</a>
</li>
<li>
<a href=https://github.com/livestalker rel=me aria-label=GitHub>
<i class="fab fa-github fa-2x" aria-hidden=true></i>
</a>
</li>
<li>
<a href=mailto:mi.aleksio@gmail.com rel=me aria-label=e-mail>
<i class="fas fa-envelope fa-2x" aria-hidden=true></i>
</a>
</li>
</ul>
</div><footer class="footer footer--sidebar">
<div class=by_farbox>
<ul class=footer__list>
<li class=footer__item>
&copy;
Alexey V. Grebenshchikov
2021
</li>
</ul>
</div>
</footer>
<script type=text/javascript src=/js/medium-zoom.min.71100d84fab0ad794b8399a66ac810700cc78d703f715dc10af4d7ba7b761362.js integrity="sha256-cRANhPqwrXlLg5mmasgQcAzHjXA/cV3BCvTXunt2E2I=" crossorigin=anonymous></script></div>
</aside>
<main>
<div class=autopagerize_page_element>
<div class=content>
<div class="post
.">
<div class=post-content>
<div class=post-title>
<h1>Как вернуть массив из C-функции.</h1>
</div><h2 id=введение-в-проблему>Введение в проблему</h2>
<p>Про то, как вернуть массив из функции на языке C, написано достаточно много статей.
Все же мне бы хотелось обобщить техники, с помощью, которых это можно сделать.</p>
<p>Давайте для примера разработаем функцию, которая будет конвертировать число в строковое
представление (эта функция будет обратная функции atoi), назовем её itoa. Как она должна
возвращать сгенерированную (строку) последовательность цифр?</p>
<p>В этой заметке рассмотрим три техники.</p>
<blockquote>
<p>Для простоты примера не будем реализовывать цикл do/while, а просто воспользуемся функцией sprintf.
Вызов этой функции настолько прост, что большинство C программ используют его непосредственно,
поэтому, наверное, и нет стандартной функции itoa.</p>
</blockquote>
<p>Давайте, посмотрим на вариант, который <em>не</em> будет работать, поэтому не пишите такой код.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>char</span> <span class=o>*</span><span class=nf>itoa</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>char</span> <span class=n>retbuf</span><span class=p>[</span><span class=mi>25</span><span class=p>];</span>
    <span class=n>sprintf</span><span class=p>(</span><span class=n>retbuf</span><span class=p>,</span> <span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>retbuf</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>На первый взгляд реализация выглядит вполне разумной (в <em>некоторых</em> случаях, этот код будет работать правильно).
Тем не менее, этот код содержит серьезную ошибку, посмотрите на переменную retbuf – это локальная переменная.
Так как, это обычная локальная переменная функции, она имеет автоматическую длительность хранения.</p>
<blockquote>
<p>Идентификатор с автоматической длительностью хранения (&ldquo;локальный идентификатор&rdquo;) имеет выделенную память
и определенное значение только внутри блока, в котором он определен или объявлен. Автоматическому идентификатору
выделяется новая память при каждом входе программы в соответствующий блок; при выходе программы из этого
блока память (и значение) идентификатора освобождается.</p>
</blockquote>
<p>Таким образом, указатель на массив, который возвращает функция itoa уже не будет существовать, когда вызывающий
код получит значение. (Оператор return retbuf; возвращает указатель на первый элемент массива retbuf.
В следствии эквивалентности массивов и указателей retbuf равносильно &retbuf[0]). Когда вызывающий код попытается
использовать указатель на созданную функцией itoa строку, он может быть все ещё валидный, либо память может уже
использоваться другой функцией. Вот почему первая версия нашей функции itoa не правильная. Функция никогда не должна
возвращать указатель на локальные переменные с автоматическим временем жизни.</p>
<h2 id=техника-со-статически-выделенным-массивом-static-array-technique>Техника со статически выделенным массивом (static array technique)</h2>
<p>Проблема с возвращением указателя на локальный массив заключается в том, что время жизни у данной переменной
автоматическое по умолчанию, самый простой способ исправить ситуацию не изменяя саму функцию itoa - это объявить
массив с модификатором static.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>char</span> <span class=o>*</span><span class=nf>itoa</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=kt>char</span> <span class=n>retbuf</span><span class=p>[</span><span class=mi>25</span><span class=p>];</span>
    <span class=n>sprintf</span><span class=p>(</span><span class=n>retbuf</span><span class=p>,</span> <span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>retbuf</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Возвращение указателя на статический выделенный массив является достаточно часто используемым решением, но у него
есть один недостаток. Каждый раз, когда вы вызываете функцию, она использует тот же самый массив и возвращает тот
же самый указатель. Поэтому, когда вы вызываете функцию второй раз, информация на которую указывает указатель будет перезаписана.</p>
<p>Рассмотрим такой пример:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>23</span><span class=p>;</span>
<span class=kt>char</span> <span class=o>*</span><span class=n>p1</span><span class=p>,</span> <span class=o>*</span><span class=n>p2</span><span class=p>;</span>
<span class=n>p1</span> <span class=o>=</span> <span class=n>itoa</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
<span class=n>i</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>10</span><span class=p>;</span>
<span class=n>p2</span> <span class=o>=</span> <span class=n>itoa</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;old i = %s, new i = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>);</span>
</code></pre></div><p>Этот код будет работать не так как мы можем ожидать. Второй вызов функции itoa перезапишет строку, которая была получена
при первом вызове. Вместо того, чтобы вывести на печать старое и новое значение, будет выведено новое значение дважды.
Обе переменные p1 и p2 будут указывать на одно и тоже место, т.к. каждый вызов itoa всегда будет возвращать один тот же указатель.</p>
<p>Рассмотрим ещё такой пример:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>printf</span><span class=p>(</span><span class=s>&#34;i = %s, j = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>itoa</span><span class=p>(</span><span class=n>i</span><span class=p>),</span> <span class=n>itoa</span><span class=p>(</span><span class=n>j</span><span class=p>));</span>
</code></pre></div><p>Где i и j две разные int переменные. Что произойдет? Либо компилятор вызовет первой первую функцию itoa либо вторую.
(Разные компиляторы могут вести себя по разному.) В каком бы порядке не происходил вызов функций результат будет один.
Функция printf напечатает два одинаковых значения.</p>
<blockquote>
<p>Вывод: реализация со статической переменной является работоспособной, но результат в вызывающем коде необходимо
использовать с осторожностью, т.к. последующие вызовы функции затрут результаты предыдущего вызова.</p>
</blockquote>
<p>Иногда, это ограничение является существенным, в других ситуациях, это вполне приемлемо. (Некоторые функции из стандартной
C библиотеки используют эту технику, например, ctime, которая конвертирует timestamp в строковое представление. Когда
в мане вы видите фразу наподобие: &ldquo;The returned pointer is to static data which is overwritten with each call'' - это
означает, что функция использует данную технику.</p>
<p>Если, указанное выше, ограничение нам не походит, можно использовать одну из следующих техник.</p>
<h2 id=техника-с-передачей-в-функцию-указателя-на-выделенный-массив-caller-passes-an-array>Техника с передачей в функцию указателя на выделенный массив (caller-passes-an-array)</h2>
<p>Если, использование статически выделенного, массива для хранения, возвращаемого, результата нам не подходит, то следующий
вариант – это выделение массива в вызывающем коде и передача указателя в вызываемую функцию.</p>
<p>В этом случае функция будет принимать, по меньшей мере, один дополнительный параметр (в дополнение к любым другим) - указатель
на место в памяти, куда необходимо записать результат. Подобным образом работает функция getline. Давайте перепишем нашу функцию подобным образом:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>char</span> <span class=o>*</span><span class=nf>itoa</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>char</span> <span class=n>buf</span><span class=p>[])</span>
<span class=p>{</span>
    <span class=n>sprintf</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>buf</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Теперь вызывающий код должен передать в функцию число и указатель на массив, куда необходимо созранить результат:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>23</span><span class=p>;</span>
<span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>25</span><span class=p>];</span>
<span class=kt>char</span> <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=n>itoa</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</code></pre></div><p>Конечно, есть пара отличий между нашей функцией и getline, если не считать, что они делают разные вещи.
Во-первых, getline принимает дополнительные параметры, в частности размер массива, для избежание переполнения.
Наша новая версия не принимает такой параметр. Если вызывающий код передаст указатель на слишком маленький массив,
то мы можем выйти за границы массива и затереть &ldquo;чужую&rdquo; память. (Естественно, последствия могут быть катастрофическими
для нашего приложения.)</p>
<p>Тем не менее, вторая, рассмотренная, стратегия так же популярна и работоспособна, как и первая со статической
локальной переменной. Вот ещё несколько функций, в которых реализована подобная техника: fgets, fread.</p>
<h2 id=техника-с-выделением-памяти-в-куче-в-вызываемой-функции-function-calls-malloc-technique>Техника с выделением памяти в куче в вызываемой функции (function-calls-malloc technique)</h2>
<p>В тех случаях, когда две выше перечисленные техники не походят (со статическим выделением памяти и выделением
массива в вызывающем коде с передачей указателя в вызываемую функцию), можно использовать третий подход,
а именно динамическое выделение памяти внутри вызываемой функции. Ниже новая версия itoa, демонстрирующая данную технику:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>char</span> <span class=o>*</span><span class=nf>itoa</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>retbuf</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>25</span><span class=p>);</span>
    <span class=k>if</span><span class=p>(</span><span class=n>retbuf</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=n>sprintf</span><span class=p>(</span><span class=n>retbuf</span><span class=p>,</span> <span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>retbuf</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Теперь получить результат в вызывающем коде можно достаточно просто:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>itoa</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</code></pre></div><p>В данной технике мы должны заботиться о следующих вещах:</p>
<ol>
<li>Новая функция itoa возвращает NULL указатель, если функция malloc не смогла выделить память. Поэтому, в вызывающем
коде, мы должны проверять возвращаемый результат каждый раз при вызове itoa до того, как начать использовать полученный указатель.</li>
<li>Если мы вызовем функцию itoa 10000 раз, мы выделим 25 * 10000 = 250000 байт памяти. Для освобождения этой памяти
необходимо использовать функцию free. Вызывающий код обязан отслеживать каждый указатель и при необходимости освобождать
занятую память, в противном случае мы можем получить утечку памяти.</li>
</ol>
<p>Первую, выше указанную, проблему можно решить следующим образом. Предположим, что у нас достаточно памяти и вызов функции
malloc будет редко приводить к ошибке, а в случае ошибки мы просто будет выводить сообщение об ошибке и завершать программу.
Таким образом проверку на нулевой указатель мы можем переместить в функцию itoa.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>char</span> <span class=o>*</span><span class=n>retbuf</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>25</span><span class=p>);</span>
<span class=k>if</span><span class=p>(</span><span class=n>retbuf</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;out of memory</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>Теперь, функция не будет возвращать нулевой указатель, поэтому вызывающему коду не нужно об этом заботиться.
Проблема только в том, что если функция malloc завершилась с ошибкой, наша программа прервет свою работу.</p>
<h2 id=итоги>Итоги</h2>
<p>Таким образом мы имеем в арсенале три метода возврата массивов из функции, ни один из которых не является совершенным и лишенным недостатков.</p>
<ol>
<li>Техника со статическим массивом удобна для вызывающего кода, но только не для случаев когда нужно вызвать несколько раз данную функцию
и получить несколько результатов. (Так же техника со статическим массивом нарушает идею, о том, что вызывающий код ничего не должен знать
о внутреннем устройстве вызываемой функции, в данном случае нам нужно знать, что массив является статическим).</li>
<li>Метод, в котором, вызывающий код передает в функцию указатель на массив может использоваться в тех случаях,
когда необходимо несколько раз вызвать функцию и получить множество результатов. Этот прием хорош, когда количество
таких вызовов не велико, и вызывающий код может легко отслеживать передаваемые массивы.</li>
<li>И, наконец, последнюю технику, удобно использовать в тех случаях, когда нам необходимо вызвать функцию множество раз,
либо нужна максимальная гибкость. За данную гибкость и удобство нам придется платить - в вызывающем коде необходимо
освобождать выделенную память.</li>
</ol>
</div>
<div class=post-footer>
<div class=info>
<span class=separator><a class=category href=/ru/categories/develop/>develop</a></span>
</div>
</div>
</div>
</div>
</div>
</main>
</div><footer class="footer footer--base">
<div class=by_farbox>
<ul class=footer__list>
<li class=footer__item>
&copy;
Alexey V. Grebenshchikov
2021
</li>
</ul>
</div>
</footer>
<script type=text/javascript src=/js/medium-zoom.min.71100d84fab0ad794b8399a66ac810700cc78d703f715dc10af4d7ba7b761362.js integrity="sha256-cRANhPqwrXlLg5mmasgQcAzHjXA/cV3BCvTXunt2E2I=" crossorigin=anonymous></script></body>
</html>